name: Emoji Smoke Test

on:
  workflow_dispatch: {}

jobs:
  emoji:
    runs-on: ubuntu-latest
    env:
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      TEAM_EMOJI_JSON: ${{ secrets.TEAM_EMOJI_JSON }}
      TEST_CHAT_ID: ${{ secrets.TEST_CHAT_ID }} # обязателен для предпросмотра в чат
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install requests
        run: pip install requests

      - name: Validate TEAM_EMOJI_JSON is readable
        run: |
          python - << 'PY'
          import os, json, sys
          raw = os.getenv('TEAM_EMOJI_JSON','')
          if not raw:
            sys.exit('TEAM_EMOJI_JSON secret is empty or missing')
          try:
            mp = json.loads(raw)
            assert isinstance(mp, dict), 'TEAM_EMOJI_JSON must be a JSON object {ABBR: id}'
            print('TEAM_EMOJI_JSON entries:', len(mp))
            bad = [k for k in mp if k.upper()!=k or len(k) not in (2,3)]
            if bad:
              print('WARNING: non-canonical keys:', bad)
          except Exception as e:
            raise SystemExit(f'Invalid TEAM_EMOJI_JSON: {e}')
          PY

      - name: Check IDs exist in Telegram (no sending)
        run: |
          python - << 'PY'
          import os, json, requests, sys
          token = os.getenv('TELEGRAM_BOT_TOKEN','').strip()
          if not token:
            sys.exit('No TELEGRAM_BOT_TOKEN')
          mapping = json.loads(os.getenv('TEAM_EMOJI_JSON','{}'))
          ids = sorted({str(v) for v in mapping.values() if v})
          if not ids:
            sys.exit('No IDs in TEAM_EMOJI_JSON')
          url = f'https://api.telegram.org/bot{token}/getCustomEmojiStickers'
          r = requests.post(url, json={'custom_emoji_ids': ids}, timeout=20)
          print('HTTP', r.status_code)
          try:
            data = r.json()
          except Exception:
            print('RAW:', r.text[:500]); sys.exit('Telegram answer not JSON')
          if not data.get('ok'):
            print('Telegram API error:', data); sys.exit(1)
          found = {s.get('custom_emoji_id') for s in data.get('result', [])}
          missing = [(abbr, cid) for abbr, cid in mapping.items() if str(cid) not in found]
          print('Found:', len(found), '/', len(ids))
          if missing:
            print('Missing or invalid IDs:')
            for abbr, cid in missing:
              print(f'  {abbr}: {cid}')
            sys.exit(2)
          else:
            print('All custom_emoji_id are valid ✅')
          PY

      - name: Dry-run entity building (no sending)
        run: |
          python - << 'PY'
          import os, json, re, sys
          mapping = json.loads(os.getenv('TEAM_EMOJI_JSON','{}'))
          # Тестовый текст с токенами {EMO:(ABBR)}ABBR
          text = " ".join([f'{{EMO:\n({abbr})\n}}{abbr}' for abbr in sorted(mapping)])
          # Правильный расчёт offset в UTF-16 код-юнитах
          def u16len(s): return len(s.encode('utf-16-le'))//2
          # ГИБКИЙ шаблон (вАЖНО: одиночные слэши!)
          pat = re.compile(r"\{\s*EMO:\s*\(([A-Z]{2,3})\)\s*\}")
          entities=[]; out_parts=[]; last=0
          for m in pat.finditer(text):
            abbr=m.group(1)
            out_parts.append(text[last:m.start()])
            start=u16len(''.join(out_parts))
            out_parts.append('⬤')
            entities.append({'type':'custom_emoji','offset':start,'length':1,'custom_emoji_id':str(mapping.get(abbr,''))})
            last=m.end()
          out_parts.append(text[last:])
          final=''.join(out_parts)
          print('Preview text snippet:', final[:200].replace('\n',' '))
          print('Entities count:', len(entities))
          if not entities:
            sys.exit('No entities built — check TEAM_EMOJI_JSON keys (must be ATL/BOS/...)')
          print('Entity building looks fine ✅')
          PY

      - name: Send per-team logos with names (to TEST_CHAT_ID)
        if: env.TEST_CHAT_ID != ''
        run: |
          python - << 'PY'
          import os, json, re, requests, sys, math
          token=os.getenv('TELEGRAM_BOT_TOKEN','').strip()
          chat=os.getenv('TEST_CHAT_ID','').strip()
          if not token or not chat:
            sys.exit('No TELEGRAM_BOT_TOKEN or TEST_CHAT_ID')
          mapping=json.loads(os.getenv('TEAM_EMOJI_JSON','{}'))  # {ABBR: custom_emoji_id}
          ABBR_TO_RU = {
            "ATL":"Атланта","BOS":"Бостон","BKN":"Бруклин","CHA":"Шарлотт","CHI":"Чикаго",
            "CLE":"Кливленд","DAL":"Даллас","DEN":"Денвер","DET":"Детройт","GSW":"Голден Стэйт",
            "HOU":"Хьюстон","IND":"Индиана","LAC":"Клипперс","LAL":"Лейкерс","MEM":"Мемфис",
            "MIA":"Майами","MIL":"Милуоки","MIN":"Миннесота","NOP":"Новый Орлеан","NYK":"Нью-Йорк",
            "OKC":"Оклахома-Сити","ORL":"Орландо","PHI":"Филадельфия","PHX":"Финикс","POR":"Портленд",
            "SAC":"Сакраменто","SAS":"Сан-Антонио","TOR":"Торонто","UTA":"Юта","WAS":"Вашингтон",
          }
          abbrs = sorted(mapping.keys())
          lines = [f'{{EMO:\n({abbr})\n}} {abbr} — {ABBR_TO_RU.get(abbr, abbr)}' for abbr in abbrs]
          def u16len(s: str) -> int: return len(s.encode('utf-16-le')) // 2
          pat = re.compile(r"\{\s*EMO:\s*\(([A-Z]{2,3})\)\s*\}")
          def build(text: str):
            entities=[]; out=[]; last=0
            for m in pat.finditer(text):
              abbr=m.group(1)
              out.append(text[last:m.start()])
              start=u16len(''.join(out))
              out.append('⬤')
              entities.append({'type':'custom_emoji','offset':start,'length':1,'custom_emoji_id':str(mapping.get(abbr,''))})
              last=m.end()
            out.append(text[last:])
            return ''.join(out), entities
          CHUNK=10
          for i in range(0, len(lines), CHUNK):
            text="\n".join(lines[i:i+CHUNK])
            final, entities = build(text)
            r = requests.post(
              f'https://api.telegram.org/bot{token}/sendMessage',
              json={'chat_id':chat,'text':final,'parse_mode':'HTML','disable_web_page_preview':True,'entities':entities},
              timeout=20
            )
            print('send:', i//CHUNK+1, r.status_code, r.text[:180])
            if r.status_code != 200:
              sys.exit('sendMessage failed')
          print('Done: sent', math.ceil(len(lines)/CHUNK), 'messages')
          PY
